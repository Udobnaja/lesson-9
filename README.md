# Алгоритмы и структуры данных

DEMO: https://udobnaja.github.io/lesson-9/

## Команды

Поставить зависимости `npm install` <br>

Запустить проект `npm run start` <br>
Собрать проект `npm run build` <br>
Деплой проекта `npm run deploy` <br>
Линтер sass `lint:sass` <br>
Линтер js `lint:js` <br>

### Описание работы и мысли

**Event Emitter**

Как я поняла нам нужно было реализовать структуру данных - Очередь (FIFO);

Первая реализация через массив, где происходит пуш эвента в массив O(1), каждый определенный тип эвента храниться в Map.
Достаем тип достается со константной сложностью O(1), перебор - линейной сложностью O(n), где n - это количество эвентов даннного типа.
При отписке нам нужно удалить эвент, хотела как в очереди просто с самого начала,
но нам нужно сначала сравнить handler и вырезать первый, делаем splice - по логике он должен отрабатывать так же,
за линейное время O(n).

Вторая реализация через одосвязные списки вставка за O(1), удаление происходит за O(1), 
но надо все равно найти определенный handler - а поиск занимает линейное время O(n);

По замерам времени, на маленькое количество, прямо выйигрыша в скорости я не увидела.
Конечно же если добавить 100000 эвентов (переменная limit в файле ./src/js/emitter.js и перед 
этим лучше закоментить вывод в консоль из хендлеров), 
то выигрывает односвязный список.

Все замеры по времени по этому заданию можно посмотреть в консоли.

Вызов всех эвентов -> click -> Execute all events Button
Отписка от асинхронных эвентов -> click -> Unsubscribe Async Button
Отписка от синхронных эвентов -> click -> Unsubscribe Usual Button

**Suggest**

Поиск подстроки в массиве строк.

Реализация -> наивная -> через includes -> поиск O(n), где n это длина массива + как я понимаю поиск в строке так же O(n), 
где n равна длине строки (линейный поиск). Конечно же делайется break по нахождению 10 ти.

Вторую реализацию я хотела сделать через стек, запоминая индекс вхождения, 
тоесть начинать уже поиск следующего символа не с самого начала, а уже с того момента, где мы закончили + забиваем в массив, по которому ищем уже надйенные результаты,
так я хотела сократить количество пробега по массиву. При условии, что искомые элементы находятся в самом конце и данных много, этот метод будет показывать лучшую скорость,
в обратной ситации чаще хуже. Тоесть вроде сложность тоже O(n), но n вроде должно уменьшаться. Добавление и удалени из стека 
 происходит за константное время, режем массив (slice) предполагаю тоже за константное времяб так как он проиндексован
По памяти вероятно этот алгоритм тоже будет хуже, потому что сохраняется slice исходного массива дополнительно каждый раз,
так же храним стек с числами.


Замеры по времени можно посмотреть в терминале выводимом на страницу. Например, поиск слова 'Остафьевское'. Все результаты 
очень варьируемы. 

Хеши. дереья, а надо ли на клиенте, или в этом и была суть?
